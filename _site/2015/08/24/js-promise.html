<!DOCTYPE html>
<html lang="en">
<head>
	<!-- 
	**
	* Author:			梦禅
	* Contact:			liulying@126.com
	* Create Date:		2015.8.17
	**
	-->
	<meta charset="UTF-8">
	<title>
		
			【转载】JavaScript Promise启示录
		
	</title>
	<meta http-equiv="X-UA-Compatible" content="IE=Edge" />
	<meta name="generator" content="Jekyll" />
	<meta name="author" content="梦 禅" />
	<meta name="descriptoin" content="" />
	<meta name="keywords" content="" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
	<link rel="shortcut icon" href="../../../img/favicon.ico" type="image/x-icon" />
	<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
	<link rel="stylesheet" href="../../../css/main.css" />
	
	<link rel="stylesheet" href="../../../css/markdown.css" />
	<link rel="stylesheet" href="../../../css/github-gist.css" />
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.7/highlight.min.js"></script>
	
	<!-- <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script> -->
	<script src="../../../js/jquery-1.11.3.min.js"></script>
	<script src="../../../js/yunlogo.js"></script>
</head>
<body>
	<div class="wrapper">
	<div class="wrap">
	<!-- 导航条部分 -->
		<div class="nav-wrap">
			<div id="logo-bg" class="blog-logo-bg">
	    <canvas id="yugen-logo-canvas" width="380" height="220"></canvas>
	    <canvas id="yugen-shadow-canvas" style="display:none;"></canvas>
	</div>
	<div class="blog-logo"><a href="/index.html"></a></div>
	<script>
		$(document).ready(function () {
	        YugenLogo.initialize( {
	            framerate: 60,

	            width: 380,
	            height: 220,

	            colorSpeedFactor: 0.4,
	            morphSpeedFactor: 0.4,
	            introSpeedFactor: 2,
	            outroSpeedFactor: 2,

	            morphStrengthFactor: 0.8,

	            morphBaseSpeedFactor: 0.2,
	            normalOffsetFactor: 1.5,

	            maxShapeRotation: 0.2,

	            wordOffsetX: 0,
	            wordOffsetY: 0,

	            wordScale: 1,

	            foregroundScaleX: 0.42,
	            foregroundScaleY: 0.21,
	            backgroundScaleX: 0.36,
	            backgroundScaleY: 0.21,

	            shadowAlpha: 0.1,

	            shapeQuality: 9,

	            containerID: "logo-bg",
	            logoCanvasID: "yugen-logo-canvas",

	            colors:[
	                [new YugenLogo.util.Color(240, 240, 240), new YugenLogo.util.Color(0, 0, 0)],
	                [new YugenLogo.util.Color(0, 0, 0), new YugenLogo.util.Color(240, 240, 240)]
	            ],

	            inputs: [
	                YugenLogo.input.move,
	                YugenLogo.input.press
	            ],

	            fallbackImages: [

	            ]
	        });
	    });
	</script>
		<ul class="nav">

    <li><a href="/index.html">首页</a></li>

    <li><a href="/blog">文章</a></li>

    <li><a href="/works.html">作品</a></li>

    <li><a href="/about.html">关于</a></li>

 </ul>
		</div>
	<!-- 主体部分 -->
		<div class="main-wrap">
			<div class="blog">
<h2 class="post-title">【转载】JavaScript Promise启示录</h2>
	<div class="tag-box">
		
		<a href="//all?tag=javascript" class="tag">javascript</a>
		
		<a href="//all?tag=前端" class="tag">前端</a>
		
		<span>(30人阅)</span>
		<span><time pubdate="">2015-08-24</time></span>
	</div>
	<div class="markdown art-content">
		<p>前段时间频频看到<code>Promise</code>这个词，今天发现腾讯AlloyTeam写得这篇很赞，遂转之。 <a href="http://www.alloyteam.com/2014/05/javascript-promise-mode/">原文链接</a></p>

<hr />

<p>本篇，主要普及promise的用法。</p>

<p>一直以来，JavaScript处理异步都是以callback的方式，在前端开发领域callback机制几乎深入人心。在设计API的时候，不管是浏览器厂商还是SDK开发商亦或是各种类库的作者，基本上都已经遵循着callback的套路。</p>

<p>近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。</p>

<p>在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：</p>

<pre><code>loadImg('a.jpg', function() {
    loadImg('b.jpg', function() {
        loadImg('c.jpg', function() {
            console.log('all done!');
        });
    });
});
</code></pre>

<p>这也就是我们常说的回调金字塔，当异步的任务很多的时候，维护大量的callback将是一场灾难。当今Node.js大热，好像很多团队都要用它来做点东西以沾沾“洋气”，曾经跟一个运维的同学聊天，他们也是打算使用Node.js做一些事情，可是一想到js的层层回调就望而却步。</p>

<p>好，扯淡完毕，下面进入正题。</p>

<p>Promise可能大家都不陌生，因为Promise规范已经出来好一段时间了，同时Promise也已经纳入了ES6，而且高版本的chrome、firefox浏览器都已经原生实现了Promise，只不过和现如今流行的类Promise类库相比少些API。</p>

<p>所谓Promise，字面上可以理解为“承诺”，就是说A调用B，B返回一个“承诺”给A，然后A就可以在写计划的时候这么写：当B返回结果给我的时候，A执行方案S1，反之如果B因为什么原因没有给到A想要的结果，那么A执行应急方案S2，这样一来，所有的潜在风险都在A的可控范围之内了。</p>

<p>上面这句话，翻译成代码类似：</p>

<pre><code>var resB = B();
var runA = function() {
    resB.then(execS1, execS2);
};
runA();
</code></pre>

<p>只看上面这行代码，好像看不出什么特别之处。但现实情况可能比这个复杂许多，A要完成一件事，可能要依赖不止B一个人的响应，可能需要同时向多个人询问，当收到所有的应答之后再执行下一步的方案。最终翻译成代码可能像这样：</p>

<pre><code>var resB = B();
var resC = C();
...
 
var runA = function() {
    reqB
        .then(resC, execS2)
        .then(resD, execS3)
        .then(resE, execS4)
        ...
       .then(execS1);
};
runA();
</code></pre>

<p>在这里，当每一个被询问者做出不符合预期的应答时都用了不同的处理机制。事实上，Promise规范没有要求这样做，你甚至可以不做任何的处理（即不传入then的第二个参数）或者统一处理。</p>

<p>好了，下面我们来认识下<a href="https://promisesaplus.com/">Promise/A+规范</a>：</p>

<ul>
  <li>一个 promise 可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）</li>
  <li>一个 promise 的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换</li>
  <li>promise 必须实现<code>then</code>方法（可以说，then 就是 promise 的核心），而且then 必须返回一个 promise，同一个 promise 的 then 可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致</li>
  <li><code>then</code> 方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise 由“等待”态转换到“拒绝”态时调用。同时，then 可以接受另一个 promise 传入，也接受一个“类then”的对象或方法，即 <code>thenable</code> 对象。</li>
</ul>

<p>可以看到，Promise规范的内容并不算多，大家可以试着自己实现以下Promise。</p>

<p>以下是笔者自己在参考许多类Promise库之后简单实现的一个Promise，代码请移步<a href="https://github.com/chemdemo/promiseA/blob/master/lib/Promise.js">PromiseA</a>.</p>

<p>简单分析下思路：</p>

<p>构造函数Promise接受一个函数resolver，可以理解为传入一个异步任务，resolver接受两个参数，一个是成功时的回调，一个是失败时的回调，这两参数和通过then传入的参数是对等的。</p>

<p>其次是then的实现，由于Promise要求then必须返回一个promise，所以在then调用的时候会新生成一个promise，挂在当前promise的_next上，同一个promise多次调用都只会返回之前生成的_next。</p>

<p>由于then方法接受的两个参数都是可选的，而且类型也没限制，可以是函数，也可以是一个具体的值，还可以是另一个promise。下面是then的具体实现：</p>

<pre><code>    Promise.prototype.then = function(resolve, reject) {
        var next = this._next || (this._next = Promise());
        var status = this.status;
        var x;
     
        if('pending' === status) {
            isFn(resolve) &amp;&amp; this._resolves.push(resolve);
            isFn(reject) &amp;&amp; this._rejects.push(reject);
            return next;
        }
     
        if('resolved' === status) {
            if(!isFn(resolve)) {
                next.resolve(resolve);
            } else {
                try {
                    x = resolve(this.value);
                    resolveX(next, x);
                } catch(e) {
                    this.reject(e);
                }
            }
            return next;
        }
     
        if('rejected' === status) {
            if(!isFn(reject)) {
                next.reject(reject);
            } else {
                try {
                    x = reject(this.reason);
                    resolveX(next, x);
                } catch(e) {
                    this.reject(e);
                }
            }
            return next;
        }
    };
</code></pre>

<p>这里，then做了简化，其他promise类库的实现比这个要复杂得多，同时功能也更多，比如还有第三个参数——notify，表示promise当前的进度，这在设计文件上传等时很有用。对then的各种参数的处理是最复杂的部分，有兴趣的同学可以参看其他类Promise库的实现。</p>

<p>在then的基础上，应该还需要至少两个方法，分别是完成promise的状态从pending到resolved或rejected的转换，同时执行相应的回调队列，即resolve()和reject()方法。</p>

<p>到此，一个简单的promise就设计完成了，下面简单实现下两个promise化的函数：</p>

<pre><code>function sleep(ms) {
    return function(v) {
        var p = Promise();
 
        setTimeout(function() {
            p.resolve(v);
        }, ms);
 
        return p;
    };
};
 
function getImg(url) {
    var p = Promise();
    var img = new Image();
 
    img.onload = function() {
        p.resolve(this);
    };
 
    img.onerror = function(err) {
        p.reject(err);
    };
 
    img.url = url;
 
    return p;
};
</code></pre>
<p>由于Promise构造函数接受一个异步任务作为参数，所以getImg还可以这样调用：</p>

<pre><code>function getImg(url) {
    return Promise(function(resolve, reject) {
        var img = new Image();
 
        img.onload = function() {
            resolve(this);
        };
 
        img.onerror = function(err) {
            reject(err);
        };
 
        img.url = url;
    });
};
</code></pre>

<p>接下来（见证奇迹的时刻），假设有一个BT的需求要这么实现：异步获取一个json配置，解析json数据拿到里边的图片，然后按顺序队列加载图片，每张图片加载时给个loading效果。</p>

<pre><code>function addImg(img) {
    $('#list').find('&gt; li:last-child').html('').append(img);
};
 
function prepend() {
    $('&lt;li&gt;')
        .html('loading...')
        .appendTo($('#list'));
};
 
function run() {
    $('#done').hide();
    getData('map.json')
        .then(function(data) {
            $('h4').html(data.name);
 
            return data.list.reduce(function(promise, item) {
                return promise
                    .then(prepend)
                    .then(sleep(1000))
                    .then(function() {
                        return getImg(item.url);
                    })
                    .then(addImg);
            }, Promise.resolve());
        })
        .then(sleep(300))
        .then(function() {
            $('#done').show();
        });
};
 
$('#run').on('click', run);
</code></pre>

<p>这里的sleep只是为了看效果加的，可猛击查看<a href="http://chemdemo.github.io/demos/promise/browser.html">demo</a>!当然，Node.js的例子可查看<a href="https://github.com/chemdemo/promiseA/blob/master/test/nodejs.js">这里</a>。</p>

<p>在这里，<code>Promise.resolve(v)</code>静态方法只是简单返回一个以v为肯定结果的promise，v可不传入，也可以是一个函数或者是一个包含then方法的对象或函数（即thenable）。</p>

<p>类似的静态方法还有<code>Promise.cast(promise)</code>，生成一个以promise为肯定结果的promise；</p>

<p><code>Promise.reject(reason)</code>，生成一个以reason为否定结果的promise。</p>

<p>我们实际的使用场景可能很复杂，往往需要多个异步的任务穿插执行，并行或者串行同在。这时候，可以对Promise进行各种扩展，比如实现<code>Promise.all()</code>，接受promises队列并等待他们完成再继续，再比如Promise.any()，promises队列中有任何一个处于完成态时即触发下一步操作。</p>

<p><strong>标准的Promise</strong></p>

<p>可参考html5rocks的这篇文章JavaScript Promises，目前高级浏览器如chrome、firefox都已经内置了Promise对象，提供更多的操作接口，比如Promise.all()，支持传入一个promises数组，当所有promises都完成时执行then，还有就是更加友好强大的异常捕获，应对日常的异步编程，应该足够了。</p>

<p><strong>第三方库的Promise</strong></p>

<p>现今流行的各大js库，几乎都不同程度的实现了Promise，如dojo，jQuery、Zepto、when.js、Q等，只是暴露出来的大都是Deferred对象，以jQuery（Zepto类似）为例，实现上面的getImg()：</p>

<pre><code>function getImg(url) {
    var def = $.Deferred();
    var img = new Image();
 
    img.onload = function() {
        def.resolve(this);
    };
 
    img.onerror = function(err) {
        def.reject(err);
    };
 
    img.src = url;
 
    return def.promise();
};
</code></pre>

<p>当然，jQuery中，很多的操作都返回的是Deferred或promise，如animate、ajax：</p>

<pre><code>// animate
$('.box')
    .animate({'opacity': 0}, 1000)
    .promise()
    .then(function() {
        console.log('done');
    });
 
// ajax
$.ajax(options).then(success, fail);
$.ajax(options).done(success).fail(fail);
 
// ajax queue
$.when($.ajax(options1), $.ajax(options2))
    .then(function() {
        console.log('all done.');
    }, function() {
        console.error('There something wrong.');
    });
</code></pre>

<p>Query还实现了done()和fail()方法，其实都是then方法的shortcut。</p>

<p>处理promises队列，jQuery实现的是$.when()方法，用法和Promise.all()类似。</p>

<p>其他类库，这里值得一提的是when.js，本身代码不多，完整实现Promise，同时支持browser和Node.js，而且提供更加丰富的API，是个不错的选择。这里限于篇幅，不再展开。</p>

<p><strong>尾声</strong></p>

<p>我们看到，不管Promise实现怎么复杂，但是它的用法却很简单，组织的代码很清晰，从此不用再受callback的折磨了。</p>

<p>最后，Promise是如此的优雅！但Promise也只是解决了回调的深层嵌套的问题，真正简化JavaScript异步编程的还是Generator，在Node.js端，建议考虑Generator。</p>

<p>下一篇，研究下Generator。</p>

<p>github原文: <a href="https://github.com/chemdemo/chemdemo.github.io/issues/6">https://github.com/chemdemo/chemdemo.github.io/issues/6</a></p>

<p><strong>参考文献</strong></p>

<ul>
  <li><a href="http://www.html5rocks.com/en/tutorials/es6/promises/">JavaScript Promises</a></li>
  <li><a href="http://www.html5rocks.com/zh/tutorials/es6/promises/">JavaScript Promises(中文)</a></li>
  <li><a href="https://github.com/cujojs/when">when.js</a></li>
  <li><a href="http://www.html5rocks.com/en/tutorials/async/deferred/">Asynch JS: The Power Of $.Deferred</a></li>
  <li><a href="https://github.com/jquery/jquery/blob/master/src/deferred.js">jQuery: $.Deferred()</a></li>
</ul>


	</div>
</div>
<!-- <div class="comment-wrap">
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'mengchan';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<div id="recent_comments">
    <h3>Recent Comments</h3>

    <div class="comment_list">
        <script type="text/javascript" src="http://mengchan.disqus.com/recent_comments_widget.js?num_items=6&hide_avatars=0&avatar_size=32&excerpt_length=200">
        </script>
    </div>
</div>
</div> -->
		


		</div>
	<!-- comment -->
		
			<div class="comment-wrap">
			<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'mengchan';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
				
					<div id="recent_comments">
    <h3>Recent Comments</h3>

    <div class="comment_list">
        <script type="text/javascript" src="http://mengchan.disqus.com/recent_comments_widget.js?num_items=6&hide_avatars=0&avatar_size=32&excerpt_length=200">
        </script>
    </div>
</div>
				
			</div>
		
	</div>
</div>
<script src="../../../js/scroll.js"></script>


	<div class="footer">
	    <p> © 2015 Zen Jekyll Theme. Design by <a href="http://www.zhanxin.info/contact.html">梦禅</a></p>
	</div>
	<script src="../../../js/main.js"></script>
	
	<script>hljs.initHighlightingOnLoad();</script>
	
</body>
</html>